{"ast":null,"code":"import * as pdfjsLib from \"pdfjs-dist/build/pdf\";\nimport pdfWorker from \"pdfjs-dist/build/pdf.worker.entry\";\n\n// Ensure worker is properly configured\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorker;\n\n/**\r\n * parsePDFSolidInk(arrayBuffer)\r\n *  For Solid Ink style invoices\r\n */\nexport async function parsePDFSolidInk(arrayBuffer) {\n  try {\n    const pdf = await pdfjsLib.getDocument({\n      data: arrayBuffer\n    }).promise;\n    let allText = \"\";\n    console.log(`PDF has ${pdf.numPages} pages`); // Debug logging\n\n    for (let i = 1; i <= pdf.numPages; i++) {\n      const page = await pdf.getPage(i);\n      const content = await page.getTextContent();\n      console.log(`Page ${i} has ${content.items.length} text items`); // Debug logging\n\n      // Extract text and transform data to preserve layout\n      const items = content.items.map(item => ({\n        text: item.str,\n        x: item.transform[4],\n        y: item.transform[5]\n      }));\n\n      // Sort items by their vertical position (y) and then horizontal position (x)\n      // For Solid Ink invoices, we need to preserve row structure\n      const sortedItems = items.sort((a, b) => {\n        // Compare y positions (higher y value = higher on page in PDF.js)\n        const yDiff = b.y - a.y;\n        // If y positions are close (same line), sort by x position\n        if (Math.abs(yDiff) < 2) {\n          return a.x - b.x;\n        }\n        return yDiff;\n      });\n\n      // Group items by their vertical position to form lines\n      let currentY = null;\n      let currentLine = [];\n      const lines = [];\n      for (const item of sortedItems) {\n        if (currentY === null || Math.abs(item.y - currentY) > 2) {\n          if (currentLine.length > 0) {\n            lines.push(currentLine.join(' '));\n          }\n          currentLine = [item.text];\n          currentY = item.y;\n        } else {\n          currentLine.push(item.text);\n        }\n      }\n      if (currentLine.length > 0) {\n        lines.push(currentLine.join(' '));\n      }\n      allText += lines.join('\\n') + '\\n';\n      console.log(`Page ${i} content:`, lines); // Debug logging\n    }\n\n    // Split into lines and filter out empty lines and headers\n    const lines = allText.split('\\n').filter(line => line.trim()).filter(line => !line.match(/^Page \\d+$/i)).filter(line => !line.match(/^(Item|Description|Ordered|Rate|Amount)$/i)).filter(line => !line.match(/^(Total|Subtotal|Invoice|Date|Ship To|Bill To)/i)).filter(line => !line.match(/^Sales Order/i)).filter(line => !line.match(/^Invoice \\d+$/i));\n    console.log('Filtered lines:', lines); // Debug logging\n\n    const results = [];\n\n    // More flexible pattern for Solid Ink invoice items\n    // Try different patterns based on the format of the invoice\n    const patterns = [\n    // Standard format: SI-1730 Baby Blue 12 $9.99 $119.88\n    /^([A-Z0-9]+(?:-[A-Z0-9]+)?)\\s+([^0-9]+?)\\s+(\\d+)\\s+\\$[\\d,.]+\\s+\\$[\\d,.]+$/i,\n    // Alternative format with spaces or special characters\n    /([A-Z0-9]+(?:-[A-Z0-9]+)?)\\s+([^0-9$]+?)\\s+(\\d+)\\s+(\\$[\\d,.]+)\\s+(\\$[\\d,.]+)/i,\n    // Format with potential missing spaces\n    /([A-Z0-9]+(?:-[A-Z0-9]+)?)\\s+([^0-9$]+)\\s*(\\d+)\\s*(\\$[\\d,.]+)\\s*(\\$[\\d,.]+)/i,\n    // Very flexible pattern for invoice items\n    /([A-Z0-9]+-?[A-Z0-9]+)\\s+(.*?)\\s+(\\d+)\\s+\\$[\\d,.]+\\s+\\$[\\d,.]+/i];\n\n    // Simpler pattern to at least capture item codes for debugging\n    const itemCodePattern = /\\b(SI-\\d+)\\b/i;\n\n    // Check each line against our patterns\n    for (const line of lines) {\n      console.log('Processing line:', line.replace(/ /g, 'Â·')); // Debug logging\n\n      let match = null;\n\n      // Try all patterns until one matches\n      for (const pattern of patterns) {\n        match = line.match(pattern);\n        if (match) break;\n      }\n\n      // If no pattern matched, try to at least extract an item code for debugging\n      if (!match) {\n        const codeMatch = line.match(itemCodePattern);\n        if (codeMatch) {\n          console.log('Found item code but format not fully recognized:', codeMatch[1]);\n          // If we have an item code, make a best effort to parse\n          const parts = line.split(/\\s+/); // Split by whitespace\n          const itemCode = codeMatch[1];\n          // Try to identify quantity (usually a number without $ sign)\n          let quantity = null;\n          let description = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (parts[i] === itemCode) {\n              // The description usually follows the item code\n              let descEnd = parts.length;\n\n              // Look for a number that might be the quantity\n              for (let j = i + 1; j < parts.length; j++) {\n                if (/^\\d+$/.test(parts[j]) && !parts[j].includes('$')) {\n                  quantity = parseInt(parts[j], 10);\n                  descEnd = j;\n                  break;\n                }\n              }\n\n              // Extract description\n              description = parts.slice(i + 1, descEnd).join(' ');\n              break;\n            }\n          }\n          if (itemCode && description && quantity) {\n            match = [null, itemCode, description, quantity.toString()];\n            console.log('Constructed match from partial data:', {\n              itemCode,\n              description,\n              quantity\n            });\n          }\n        }\n      }\n      if (match) {\n        const [, itemCode, description, quantityStr] = match;\n        console.log('Matched components:', {\n          itemCode,\n          description,\n          quantityStr\n        }); // Debug logging\n        const quantity = parseInt(quantityStr.replace(/,/g, ''), 10);\n\n        // Extract size from item code or description\n        let size = \"1 ounce\"; // default\n        if (itemCode.includes(\"-1/2\") || description.toLowerCase().includes(\"1/2 ounce\") || description.toLowerCase().includes(\"1/2oz\")) {\n          size = \"1/2 ounce\";\n        } else if (itemCode.includes(\"-4\") || description.toLowerCase().includes(\"4 ounce\") || description.toLowerCase().includes(\"4oz\")) {\n          size = \"4 ounce\";\n        } else if (itemCode.includes(\"-2\") || description.toLowerCase().includes(\"2 ounce\") || description.toLowerCase().includes(\"2oz\")) {\n          size = \"2 ounce\";\n        }\n\n        // Clean up color name by removing size references and other common text\n        const color = description.replace(/-1 ounce Bottle/i, \"\").replace(/-1\\/2 ounce/i, \"\").replace(/-4 ounce/i, \"\").replace(/-2 ounce/i, \"\").replace(/\\s*Bottle.*$/i, \"\") // Remove \"Bottle\" and anything after it\n        .replace(/\\s*Set.*$/i, \"\") // Remove \"Set\" and anything after it\n        .replace(/\\s*\\([^)]*\\)/g, \"\") // Remove any parenthetical notes\n        .replace(/\\s+1oz\\b/i, \"\").replace(/\\s+2oz\\b/i, \"\").replace(/\\s+4oz\\b/i, \"\").replace(/\\s+1\\/2oz\\b/i, \"\").replace(/\\s+1 ounce\\b/i, \"\").replace(/\\s+2 ounce\\b/i, \"\").replace(/\\s+4 ounce\\b/i, \"\").replace(/\\s+1\\/2 ounce\\b/i, \"\").trim();\n\n        // Skip discount lines and empty colors\n        if (!itemCode.includes(\"Discount\") && color && !color.match(/^(ounce|Bottle|Bottles)$/i)) {\n          results.push({\n            itemCode,\n            color,\n            quantity: quantity,\n            size\n          });\n          console.log('Successfully parsed item:', {\n            itemCode,\n            color,\n            quantity,\n            size\n          }); // Debug logging\n        }\n      } else {\n        console.log('Line did not match any pattern:', line); // Debug logging\n      }\n    }\n\n    // If we couldn't parse any items using our patterns,\n    // try a more brute-force approach as a fallback\n    if (results.length === 0) {\n      console.log('No items matched patterns, trying fallback approach');\n\n      // Look for item codes with SI- prefix anywhere in the text\n      const itemCodeMatches = allText.match(/\\b(SI-\\d+)\\b/gi);\n      if (itemCodeMatches && itemCodeMatches.length > 0) {\n        console.log('Found item codes with fallback approach:', itemCodeMatches);\n\n        // Create dummy items for each code found\n        for (const code of itemCodeMatches) {\n          results.push({\n            itemCode: code,\n            color: 'Unknown Color',\n            // Default placeholder\n            quantity: 1,\n            // Default quantity\n            size: '1 ounce' // Default size\n          });\n        }\n      }\n    }\n    if (results.length === 0) {\n      console.error('No items could be parsed from the PDF');\n      throw new Error('No items could be parsed from the PDF');\n    }\n    console.log(`Parsed ${results.length} items successfully`);\n    return results;\n  } catch (error) {\n    console.error('Error parsing PDF:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["pdfjsLib","pdfWorker","GlobalWorkerOptions","workerSrc","parsePDFSolidInk","arrayBuffer","pdf","getDocument","data","promise","allText","console","log","numPages","i","page","getPage","content","getTextContent","items","length","map","item","text","str","x","transform","y","sortedItems","sort","a","b","yDiff","Math","abs","currentY","currentLine","lines","push","join","split","filter","line","trim","match","results","patterns","itemCodePattern","replace","pattern","codeMatch","parts","itemCode","quantity","description","descEnd","j","test","includes","parseInt","slice","toString","quantityStr","size","toLowerCase","color","itemCodeMatches","code","error","Error"],"sources":["C:/Users/hongjie/Desktop/Warehouse Test/src/parsers/solidInkParser.js"],"sourcesContent":["import * as pdfjsLib from \"pdfjs-dist/build/pdf\";\r\nimport pdfWorker from \"pdfjs-dist/build/pdf.worker.entry\";\r\n\r\n// Ensure worker is properly configured\r\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorker;\r\n\r\n/**\r\n * parsePDFSolidInk(arrayBuffer)\r\n *  For Solid Ink style invoices\r\n */\r\nexport async function parsePDFSolidInk(arrayBuffer) {\r\n  try {\r\n    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\r\n    let allText = \"\";\r\n    \r\n    console.log(`PDF has ${pdf.numPages} pages`); // Debug logging\r\n\r\n    for (let i = 1; i <= pdf.numPages; i++) {\r\n      const page = await pdf.getPage(i);\r\n      const content = await page.getTextContent();\r\n      \r\n      console.log(`Page ${i} has ${content.items.length} text items`); // Debug logging\r\n      \r\n      // Extract text and transform data to preserve layout\r\n      const items = content.items.map(item => ({\r\n        text: item.str,\r\n        x: item.transform[4],\r\n        y: item.transform[5]\r\n      }));\r\n      \r\n      // Sort items by their vertical position (y) and then horizontal position (x)\r\n      // For Solid Ink invoices, we need to preserve row structure\r\n      const sortedItems = items.sort((a, b) => {\r\n        // Compare y positions (higher y value = higher on page in PDF.js)\r\n        const yDiff = b.y - a.y;\r\n        // If y positions are close (same line), sort by x position\r\n        if (Math.abs(yDiff) < 2) {\r\n          return a.x - b.x;\r\n        }\r\n        return yDiff;\r\n      });\r\n\r\n      // Group items by their vertical position to form lines\r\n      let currentY = null;\r\n      let currentLine = [];\r\n      const lines = [];\r\n\r\n      for (const item of sortedItems) {\r\n        if (currentY === null || Math.abs(item.y - currentY) > 2) {\r\n          if (currentLine.length > 0) {\r\n            lines.push(currentLine.join(' '));\r\n          }\r\n          currentLine = [item.text];\r\n          currentY = item.y;\r\n        } else {\r\n          currentLine.push(item.text);\r\n        }\r\n      }\r\n      \r\n      if (currentLine.length > 0) {\r\n        lines.push(currentLine.join(' '));\r\n      }\r\n\r\n      allText += lines.join('\\n') + '\\n';\r\n      console.log(`Page ${i} content:`, lines); // Debug logging\r\n    }\r\n\r\n    // Split into lines and filter out empty lines and headers\r\n    const lines = allText.split('\\n')\r\n      .filter(line => line.trim())\r\n      .filter(line => !line.match(/^Page \\d+$/i))\r\n      .filter(line => !line.match(/^(Item|Description|Ordered|Rate|Amount)$/i))\r\n      .filter(line => !line.match(/^(Total|Subtotal|Invoice|Date|Ship To|Bill To)/i))\r\n      .filter(line => !line.match(/^Sales Order/i))\r\n      .filter(line => !line.match(/^Invoice \\d+$/i));\r\n\r\n    console.log('Filtered lines:', lines); // Debug logging\r\n    \r\n    const results = [];\r\n    \r\n    // More flexible pattern for Solid Ink invoice items\r\n    // Try different patterns based on the format of the invoice\r\n    const patterns = [\r\n      // Standard format: SI-1730 Baby Blue 12 $9.99 $119.88\r\n      /^([A-Z0-9]+(?:-[A-Z0-9]+)?)\\s+([^0-9]+?)\\s+(\\d+)\\s+\\$[\\d,.]+\\s+\\$[\\d,.]+$/i,\r\n      \r\n      // Alternative format with spaces or special characters\r\n      /([A-Z0-9]+(?:-[A-Z0-9]+)?)\\s+([^0-9$]+?)\\s+(\\d+)\\s+(\\$[\\d,.]+)\\s+(\\$[\\d,.]+)/i,\r\n      \r\n      // Format with potential missing spaces\r\n      /([A-Z0-9]+(?:-[A-Z0-9]+)?)\\s+([^0-9$]+)\\s*(\\d+)\\s*(\\$[\\d,.]+)\\s*(\\$[\\d,.]+)/i,\r\n      \r\n      // Very flexible pattern for invoice items\r\n      /([A-Z0-9]+-?[A-Z0-9]+)\\s+(.*?)\\s+(\\d+)\\s+\\$[\\d,.]+\\s+\\$[\\d,.]+/i\r\n    ];\r\n    \r\n    // Simpler pattern to at least capture item codes for debugging\r\n    const itemCodePattern = /\\b(SI-\\d+)\\b/i;\r\n    \r\n    // Check each line against our patterns\r\n    for (const line of lines) {\r\n      console.log('Processing line:', line.replace(/ /g, 'Â·')); // Debug logging\r\n      \r\n      let match = null;\r\n      \r\n      // Try all patterns until one matches\r\n      for (const pattern of patterns) {\r\n        match = line.match(pattern);\r\n        if (match) break;\r\n      }\r\n      \r\n      // If no pattern matched, try to at least extract an item code for debugging\r\n      if (!match) {\r\n        const codeMatch = line.match(itemCodePattern);\r\n        if (codeMatch) {\r\n          console.log('Found item code but format not fully recognized:', codeMatch[1]);\r\n          // If we have an item code, make a best effort to parse\r\n          const parts = line.split(/\\s+/); // Split by whitespace\r\n          const itemCode = codeMatch[1];\r\n          // Try to identify quantity (usually a number without $ sign)\r\n          let quantity = null;\r\n          let description = '';\r\n          \r\n          for (let i = 0; i < parts.length; i++) {\r\n            if (parts[i] === itemCode) {\r\n              // The description usually follows the item code\r\n              let descEnd = parts.length;\r\n              \r\n              // Look for a number that might be the quantity\r\n              for (let j = i + 1; j < parts.length; j++) {\r\n                if (/^\\d+$/.test(parts[j]) && !parts[j].includes('$')) {\r\n                  quantity = parseInt(parts[j], 10);\r\n                  descEnd = j;\r\n                  break;\r\n                }\r\n              }\r\n              \r\n              // Extract description\r\n              description = parts.slice(i + 1, descEnd).join(' ');\r\n              break;\r\n            }\r\n          }\r\n          \r\n          if (itemCode && description && quantity) {\r\n            match = [null, itemCode, description, quantity.toString()];\r\n            console.log('Constructed match from partial data:', { itemCode, description, quantity });\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (match) {\r\n        const [, itemCode, description, quantityStr] = match;\r\n        console.log('Matched components:', { itemCode, description, quantityStr }); // Debug logging\r\n        const quantity = parseInt(quantityStr.replace(/,/g, ''), 10);\r\n\r\n        // Extract size from item code or description\r\n        let size = \"1 ounce\"; // default\r\n        if (itemCode.includes(\"-1/2\") || description.toLowerCase().includes(\"1/2 ounce\") || description.toLowerCase().includes(\"1/2oz\")) {\r\n          size = \"1/2 ounce\";\r\n        } else if (itemCode.includes(\"-4\") || description.toLowerCase().includes(\"4 ounce\") || description.toLowerCase().includes(\"4oz\")) {\r\n          size = \"4 ounce\";\r\n        } else if (itemCode.includes(\"-2\") || description.toLowerCase().includes(\"2 ounce\") || description.toLowerCase().includes(\"2oz\")) {\r\n          size = \"2 ounce\";\r\n        }\r\n\r\n        // Clean up color name by removing size references and other common text\r\n        const color = description\r\n          .replace(/-1 ounce Bottle/i, \"\")\r\n          .replace(/-1\\/2 ounce/i, \"\")\r\n          .replace(/-4 ounce/i, \"\")\r\n          .replace(/-2 ounce/i, \"\")\r\n          .replace(/\\s*Bottle.*$/i, \"\") // Remove \"Bottle\" and anything after it\r\n          .replace(/\\s*Set.*$/i, \"\") // Remove \"Set\" and anything after it\r\n          .replace(/\\s*\\([^)]*\\)/g, \"\") // Remove any parenthetical notes\r\n          .replace(/\\s+1oz\\b/i, \"\")\r\n          .replace(/\\s+2oz\\b/i, \"\")\r\n          .replace(/\\s+4oz\\b/i, \"\")\r\n          .replace(/\\s+1\\/2oz\\b/i, \"\")\r\n          .replace(/\\s+1 ounce\\b/i, \"\")\r\n          .replace(/\\s+2 ounce\\b/i, \"\")\r\n          .replace(/\\s+4 ounce\\b/i, \"\")\r\n          .replace(/\\s+1\\/2 ounce\\b/i, \"\")\r\n          .trim();\r\n\r\n        // Skip discount lines and empty colors\r\n        if (!itemCode.includes(\"Discount\") && color && !color.match(/^(ounce|Bottle|Bottles)$/i)) {\r\n          results.push({\r\n            itemCode,\r\n            color,\r\n            quantity: quantity,\r\n            size\r\n          });\r\n          console.log('Successfully parsed item:', { itemCode, color, quantity, size }); // Debug logging\r\n        }\r\n      } else {\r\n        console.log('Line did not match any pattern:', line); // Debug logging\r\n      }\r\n    }\r\n\r\n    // If we couldn't parse any items using our patterns,\r\n    // try a more brute-force approach as a fallback\r\n    if (results.length === 0) {\r\n      console.log('No items matched patterns, trying fallback approach');\r\n      \r\n      // Look for item codes with SI- prefix anywhere in the text\r\n      const itemCodeMatches = allText.match(/\\b(SI-\\d+)\\b/gi);\r\n      \r\n      if (itemCodeMatches && itemCodeMatches.length > 0) {\r\n        console.log('Found item codes with fallback approach:', itemCodeMatches);\r\n        \r\n        // Create dummy items for each code found\r\n        for (const code of itemCodeMatches) {\r\n          results.push({\r\n            itemCode: code,\r\n            color: 'Unknown Color', // Default placeholder\r\n            quantity: 1, // Default quantity\r\n            size: '1 ounce' // Default size\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    if (results.length === 0) {\r\n      console.error('No items could be parsed from the PDF');\r\n      throw new Error('No items could be parsed from the PDF');\r\n    }\r\n\r\n    console.log(`Parsed ${results.length} items successfully`);\r\n    return results;\r\n  } catch (error) {\r\n    console.error('Error parsing PDF:', error);\r\n    throw error;\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}