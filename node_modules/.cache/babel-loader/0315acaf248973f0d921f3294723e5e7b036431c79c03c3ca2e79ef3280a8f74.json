{"ast":null,"code":"// src/parsers/eternalParser.js\nimport * as pdfjsLib from \"pdfjs-dist/build/pdf\";\nimport pdfWorker from \"pdfjs-dist/build/pdf.worker.entry\";\n\n// Ensure worker is properly configured\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorker;\n\n/**\r\n * parsePDFEternal(arrayBuffer)\r\n *  For Eternal Ink style invoices\r\n */\nexport async function parsePDFEternal(arrayBuffer) {\n  try {\n    const pdf = await pdfjsLib.getDocument({\n      data: arrayBuffer\n    }).promise;\n    let allText = \"\";\n    for (let i = 1; i <= pdf.numPages; i++) {\n      const page = await pdf.getPage(i);\n      const content = await page.getTextContent();\n      const pageText = content.items.map(item => item.str).join(\" \");\n      allText += pageText + \"\\n\";\n      console.log(`Page ${i} text:`, pageText); // Debug logging\n    }\n\n    // Split into lines and filter out empty lines and page markers\n    const lines = allText.split('\\n').filter(line => line.trim()).filter(line => !line.match(/^Page \\d+$/)).filter(line => !line.match(/^Sales Order$/)).filter(line => !line.match(/^Date$/)).filter(line => !line.match(/^S\\.O\\. No\\.$/)).filter(line => !line.match(/^Name \\/ Address$/)).filter(line => !line.match(/^Ship To$/)).filter(line => !line.match(/^P\\.O\\. No\\.$/)).filter(line => !line.match(/^Rep$/)).filter(line => !line.match(/^Project$/)).filter(line => !line.match(/^Total$/)).filter(line => !line.match(/^Item$/)).filter(line => !line.match(/^Description$/)).filter(line => !line.match(/^Ordered$/)).filter(line => !line.match(/^Rate$/)).filter(line => !line.match(/^Amount$/)).filter(line => !line.match(/^Discount\\.$/)).filter(line => !line.match(/^Shipment Carrier:/)).filter(line => !line.match(/^Payment Method:/)).filter(line => !line.match(/^\\$[\\d,.]+$/)); // Filter out total amount lines\n\n    console.log('Filtered lines:', lines); // Debug logging\n\n    const results = [];\n    for (const line of lines) {\n      // More flexible pattern matching for Eternal invoice lines\n      const match = line.match(/^([A-Z0-9]+(?:-[0-9]+(?:\\/[0-9]+)?(?:NB)?)?)\\s+([^0-9]+?)\\s+(\\d+(?:,\\d+)?)\\s*(?:[\\d.,]+\\s*[\\d.,]+)?$/);\n      if (match) {\n        const [, itemCode, description, qtyStr] = match;\n        const quantity = parseInt(qtyStr.replace(/,/g, ''), 10);\n\n        // Extract size from item code or description with more patterns\n        let size = \"1 ounce\"; // default\n        const sizePatterns = [{\n          pattern: /-1\\/2/,\n          size: \"1/2 ounce\"\n        }, {\n          pattern: /-4/,\n          size: \"4 ounce\"\n        }, {\n          pattern: /-2/,\n          size: \"2 ounce\"\n        }, {\n          pattern: /1\\s*ounce|1oz/i,\n          size: \"1 ounce\"\n        }, {\n          pattern: /1\\/2\\s*ounce|1\\/2oz/i,\n          size: \"1/2 ounce\"\n        }, {\n          pattern: /4\\s*ounce|4oz/i,\n          size: \"4 ounce\"\n        }, {\n          pattern: /2\\s*ounce|2oz/i,\n          size: \"2 ounce\"\n        }];\n        for (const {\n          pattern,\n          size: matchedSize\n        } of sizePatterns) {\n          if (itemCode.match(pattern) || description.match(pattern)) {\n            size = matchedSize;\n            break;\n          }\n        }\n\n        // Clean up color name with more patterns\n        const color = description.replace(/-1 ounce Bottle/i, \"\").replace(/-1\\/2 ounce/i, \"\").replace(/-4 ounce/i, \"\").replace(/-2 ounce/i, \"\").replace(/-1oz/i, \"\").replace(/-1\\/2oz/i, \"\").replace(/-4oz/i, \"\").replace(/-2oz/i, \"\").replace(/\\s*\\([^)]*\\)/g, \"\") // Remove any parenthetical notes\n        .replace(/\\s*Set.*$/i, \"\") // Remove \"Set\" and anything after it\n        .replace(/\\s*Bottle.*$/i, \"\") // Remove \"Bottle\" and anything after it\n        .replace(/\\s*-1 ounce$/i, \"\") // Remove size suffix\n        .replace(/\\s*-1\\/2 ounce$/i, \"\").replace(/\\s*-4 ounce$/i, \"\").replace(/\\s*-2 ounce$/i, \"\").replace(/\\s*\\(.*\\)/g, \"\") // Remove any remaining parenthetical notes\n        .replace(/\\s*\\[.*\\]/g, \"\") // Remove any bracketed notes\n        .trim();\n\n        // Skip discount lines and empty colors\n        if (!itemCode.includes(\"Discount\") && color && !color.match(/^(ounce|Bottle|Bottles)$/i)) {\n          results.push({\n            itemCode,\n            color,\n            quantity,\n            size\n          });\n          console.log('Successfully parsed item:', {\n            itemCode,\n            color,\n            quantity,\n            size\n          }); // Debug logging\n        }\n      } else {\n        console.log('Line did not match pattern:', line); // Debug logging\n      }\n    }\n    if (results.length === 0) {\n      console.error('No items could be parsed from the PDF');\n      throw new Error('No items could be parsed from the PDF');\n    }\n    console.log('Parsed results:', results); // Debug logging\n    return results;\n  } catch (error) {\n    console.error('Error parsing PDF:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["pdfjsLib","pdfWorker","GlobalWorkerOptions","workerSrc","parsePDFEternal","arrayBuffer","pdf","getDocument","data","promise","allText","i","numPages","page","getPage","content","getTextContent","pageText","items","map","item","str","join","console","log","lines","split","filter","line","trim","match","results","itemCode","description","qtyStr","quantity","parseInt","replace","size","sizePatterns","pattern","matchedSize","color","includes","push","length","error","Error"],"sources":["C:/Users/hongjie/Desktop/Warehouse Test/src/parsers/eternalParser.js"],"sourcesContent":["// src/parsers/eternalParser.js\r\nimport * as pdfjsLib from \"pdfjs-dist/build/pdf\";\r\nimport pdfWorker from \"pdfjs-dist/build/pdf.worker.entry\";\r\n\r\n// Ensure worker is properly configured\r\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorker;\r\n\r\n/**\r\n * parsePDFEternal(arrayBuffer)\r\n *  For Eternal Ink style invoices\r\n */\r\nexport async function parsePDFEternal(arrayBuffer) {\r\n  try {\r\n    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\r\n    let allText = \"\";\r\n\r\n    for (let i = 1; i <= pdf.numPages; i++) {\r\n      const page = await pdf.getPage(i);\r\n      const content = await page.getTextContent();\r\n      const pageText = content.items.map((item) => item.str).join(\" \");\r\n      allText += pageText + \"\\n\";\r\n      console.log(`Page ${i} text:`, pageText); // Debug logging\r\n    }\r\n\r\n    // Split into lines and filter out empty lines and page markers\r\n    const lines = allText.split('\\n')\r\n      .filter(line => line.trim())\r\n      .filter(line => !line.match(/^Page \\d+$/))\r\n      .filter(line => !line.match(/^Sales Order$/))\r\n      .filter(line => !line.match(/^Date$/))\r\n      .filter(line => !line.match(/^S\\.O\\. No\\.$/))\r\n      .filter(line => !line.match(/^Name \\/ Address$/))\r\n      .filter(line => !line.match(/^Ship To$/))\r\n      .filter(line => !line.match(/^P\\.O\\. No\\.$/))\r\n      .filter(line => !line.match(/^Rep$/))\r\n      .filter(line => !line.match(/^Project$/))\r\n      .filter(line => !line.match(/^Total$/))\r\n      .filter(line => !line.match(/^Item$/))\r\n      .filter(line => !line.match(/^Description$/))\r\n      .filter(line => !line.match(/^Ordered$/))\r\n      .filter(line => !line.match(/^Rate$/))\r\n      .filter(line => !line.match(/^Amount$/))\r\n      .filter(line => !line.match(/^Discount\\.$/))\r\n      .filter(line => !line.match(/^Shipment Carrier:/))\r\n      .filter(line => !line.match(/^Payment Method:/))\r\n      .filter(line => !line.match(/^\\$[\\d,.]+$/)); // Filter out total amount lines\r\n    \r\n    console.log('Filtered lines:', lines); // Debug logging\r\n    \r\n    const results = [];\r\n\r\n    for (const line of lines) {\r\n      // More flexible pattern matching for Eternal invoice lines\r\n      const match = line.match(/^([A-Z0-9]+(?:-[0-9]+(?:\\/[0-9]+)?(?:NB)?)?)\\s+([^0-9]+?)\\s+(\\d+(?:,\\d+)?)\\s*(?:[\\d.,]+\\s*[\\d.,]+)?$/);\r\n      \r\n      if (match) {\r\n        const [, itemCode, description, qtyStr] = match;\r\n        const quantity = parseInt(qtyStr.replace(/,/g, ''), 10);\r\n\r\n        // Extract size from item code or description with more patterns\r\n        let size = \"1 ounce\"; // default\r\n        const sizePatterns = [\r\n          { pattern: /-1\\/2/, size: \"1/2 ounce\" },\r\n          { pattern: /-4/, size: \"4 ounce\" },\r\n          { pattern: /-2/, size: \"2 ounce\" },\r\n          { pattern: /1\\s*ounce|1oz/i, size: \"1 ounce\" },\r\n          { pattern: /1\\/2\\s*ounce|1\\/2oz/i, size: \"1/2 ounce\" },\r\n          { pattern: /4\\s*ounce|4oz/i, size: \"4 ounce\" },\r\n          { pattern: /2\\s*ounce|2oz/i, size: \"2 ounce\" }\r\n        ];\r\n\r\n        for (const { pattern, size: matchedSize } of sizePatterns) {\r\n          if (itemCode.match(pattern) || description.match(pattern)) {\r\n            size = matchedSize;\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Clean up color name with more patterns\r\n        const color = description\r\n          .replace(/-1 ounce Bottle/i, \"\")\r\n          .replace(/-1\\/2 ounce/i, \"\")\r\n          .replace(/-4 ounce/i, \"\")\r\n          .replace(/-2 ounce/i, \"\")\r\n          .replace(/-1oz/i, \"\")\r\n          .replace(/-1\\/2oz/i, \"\")\r\n          .replace(/-4oz/i, \"\")\r\n          .replace(/-2oz/i, \"\")\r\n          .replace(/\\s*\\([^)]*\\)/g, \"\") // Remove any parenthetical notes\r\n          .replace(/\\s*Set.*$/i, \"\") // Remove \"Set\" and anything after it\r\n          .replace(/\\s*Bottle.*$/i, \"\") // Remove \"Bottle\" and anything after it\r\n          .replace(/\\s*-1 ounce$/i, \"\") // Remove size suffix\r\n          .replace(/\\s*-1\\/2 ounce$/i, \"\")\r\n          .replace(/\\s*-4 ounce$/i, \"\")\r\n          .replace(/\\s*-2 ounce$/i, \"\")\r\n          .replace(/\\s*\\(.*\\)/g, \"\") // Remove any remaining parenthetical notes\r\n          .replace(/\\s*\\[.*\\]/g, \"\") // Remove any bracketed notes\r\n          .trim();\r\n\r\n        // Skip discount lines and empty colors\r\n        if (!itemCode.includes(\"Discount\") && color && !color.match(/^(ounce|Bottle|Bottles)$/i)) {\r\n          results.push({\r\n            itemCode,\r\n            color,\r\n            quantity,\r\n            size\r\n          });\r\n          console.log('Successfully parsed item:', { itemCode, color, quantity, size }); // Debug logging\r\n        }\r\n      } else {\r\n        console.log('Line did not match pattern:', line); // Debug logging\r\n      }\r\n    }\r\n\r\n    if (results.length === 0) {\r\n      console.error('No items could be parsed from the PDF');\r\n      throw new Error('No items could be parsed from the PDF');\r\n    }\r\n\r\n    console.log('Parsed results:', results); // Debug logging\r\n    return results;\r\n  } catch (error) {\r\n    console.error('Error parsing PDF:', error);\r\n    throw error;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}