{"ast":null,"code":"import * as pdfjsLib from \"pdfjs-dist/build/pdf\";\nimport pdfWorker from \"pdfjs-dist/build/pdf.worker.entry\";\n\n// Ensure worker is properly configured\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorker;\n\n/**\r\n * parsePDFSolidInk(arrayBuffer)\r\n *  For Solid Ink style invoices\r\n */\nexport async function parsePDFSolidInk(arrayBuffer) {\n  try {\n    const pdf = await pdfjsLib.getDocument({\n      data: arrayBuffer\n    }).promise;\n    console.log(`PDF has ${pdf.numPages} pages`);\n    let allLines = [];\n    for (let i = 1; i <= pdf.numPages; i++) {\n      const page = await pdf.getPage(i);\n      const textContent = await page.getTextContent();\n      console.log(`Page ${i} has ${textContent.items.length} text items`);\n\n      // Group items by vertical position (approximate lines)\n      const lineMap = new Map();\n      textContent.items.forEach(item => {\n        const y = Math.round(item.transform[5]); // Get y coordinate\n        if (!lineMap.has(y)) {\n          lineMap.set(y, []);\n        }\n        lineMap.get(y).push({\n          text: item.str,\n          x: item.transform[4]\n        });\n      });\n\n      // Sort lines by y coordinate (top to bottom) and combine items in each line\n      const lines = Array.from(lineMap.entries()).sort((a, b) => b[0] - a[0]) // Sort by y coordinate\n      .map(([_, items]) => {\n        // Sort items by x coordinate and join\n        return items.sort((a, b) => a.x - b.x).map(item => item.text).join(' ').trim();\n      }).filter(line => line.length > 0);\n      allLines = allLines.concat(lines);\n    }\n\n    // Filter out header lines and other non-item lines\n    const filteredLines = allLines.filter(line => !line.match(/^Page \\d+$/i) && !line.match(/^(Item|Description|Ordered|Rate|Amount)$/i) && !line.match(/^(Total|Subtotal|Invoice|Date|Ship To|Bill To)/i) && !line.match(/^Sales Order/i) && !line.match(/^Invoice \\d+$/i));\n    console.log('Filtered lines:', filteredLines);\n    const items = [];\n\n    // Process for item extraction\n    for (let i = 0; i < filteredLines.length; i++) {\n      const line = filteredLines[i];\n\n      // Look for SI- item codes\n      if (line.includes('SI-')) {\n        // This is likely a product line\n        const itemCodeMatch = line.match(/\\b(SI-\\d+)\\b/i);\n        if (itemCodeMatch) {\n          const itemCode = itemCodeMatch[1];\n          const parts = line.split(/\\s+/);\n\n          // Find item code position in the parts array\n          let itemCodePos = -1;\n          for (let j = 0; j < parts.length; j++) {\n            if (parts[j].toUpperCase() === itemCode.toUpperCase()) {\n              itemCodePos = j;\n              break;\n            }\n          }\n          if (itemCodePos >= 0) {\n            // Find first dollar sign position\n            let dollarPos = -1;\n            for (let j = 0; j < parts.length; j++) {\n              if (parts[j].startsWith('$')) {\n                dollarPos = j;\n                break;\n              }\n            }\n            if (dollarPos > itemCodePos) {\n              // Extract quantity - it's usually the number right before the dollar sign\n              let quantity = 1;\n              let quantityPos = -1;\n              if (dollarPos > 0) {\n                const possibleQty = parts[dollarPos - 1];\n                if (/^\\d+$/.test(possibleQty)) {\n                  quantity = parseInt(possibleQty, 10);\n                  quantityPos = dollarPos - 1;\n                }\n              }\n\n              // Extract description - it's between item code and quantity\n              let description = '';\n              if (quantityPos > itemCodePos + 1) {\n                // Description is between item code and quantity\n                description = parts.slice(itemCodePos + 1, quantityPos).join(' ');\n              } else if (dollarPos > itemCodePos + 1) {\n                // If we couldn't identify quantity, description is everything before $\n                description = parts.slice(itemCodePos + 1, dollarPos).join(' ');\n              }\n\n              // Extract size from item code or description\n              let size = \"1 ounce\"; // default\n              if (itemCode.includes(\"-1/2\") || description.toLowerCase().includes(\"1/2 ounce\") || description.toLowerCase().includes(\"1/2oz\")) {\n                size = \"1/2 ounce\";\n              } else if (itemCode.includes(\"-4\") || description.toLowerCase().includes(\"4 ounce\") || description.toLowerCase().includes(\"4oz\")) {\n                size = \"4 ounce\";\n              } else if (itemCode.includes(\"-2\") || description.toLowerCase().includes(\"2 ounce\") || description.toLowerCase().includes(\"2oz\")) {\n                size = \"2 ounce\";\n              }\n\n              // Clean up color name\n              const color = description.replace(/-1 ounce Bottle/i, \"\").replace(/-1\\/2 ounce/i, \"\").replace(/-4 ounce/i, \"\").replace(/-2 ounce/i, \"\").replace(/\\s*Bottle.*$/i, \"\") // Remove \"Bottle\" and anything after it\n              .replace(/\\s*Set.*$/i, \"\") // Remove \"Set\" and anything after it\n              .replace(/\\s*\\([^)]*\\)/g, \"\") // Remove any parenthetical notes\n              .replace(/\\s+1oz\\b/i, \"\").replace(/\\s+2oz\\b/i, \"\").replace(/\\s+4oz\\b/i, \"\").replace(/\\s+1\\/2oz\\b/i, \"\").replace(/\\s+1 ounce\\b/i, \"\").replace(/\\s+2 ounce\\b/i, \"\").replace(/\\s+4 ounce\\b/i, \"\").replace(/\\s+1\\/2 ounce\\b/i, \"\").trim();\n              if (color && !color.match(/^(ounce|Bottle|Bottles)$/i) && quantity > 0) {\n                items.push({\n                  itemCode,\n                  color,\n                  quantity,\n                  size\n                });\n                console.log('Extracted item:', {\n                  itemCode,\n                  color,\n                  quantity,\n                  size\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // If we couldn't parse using line-by-line approach, try to find items directly from all text\n    if (items.length === 0) {\n      console.log('Line parsing failed, trying direct item code extraction');\n\n      // Get all text as a single string to search for item codes\n      const allText = filteredLines.join(' ');\n\n      // Extract all SI- item codes\n      const itemCodes = allText.match(/\\bSI-\\d+\\b/gi);\n      if (itemCodes && itemCodes.length > 0) {\n        console.log(`Found ${itemCodes.length} item codes, creating placeholder items`);\n\n        // Create a basic item for each code found\n        for (const code of itemCodes) {\n          items.push({\n            itemCode: code,\n            color: 'Unknown Color',\n            // We'll need to manually edit these later\n            quantity: 1,\n            // Default quantity\n            size: '1 ounce' // Default size\n          });\n        }\n      }\n    }\n    if (items.length === 0) {\n      console.error('No items could be parsed from the PDF');\n      throw new Error('No items could be parsed from the PDF');\n    }\n    console.log(`Successfully parsed ${items.length} items from invoice`);\n    return items;\n  } catch (error) {\n    console.error('Error parsing PDF:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["pdfjsLib","pdfWorker","GlobalWorkerOptions","workerSrc","parsePDFSolidInk","arrayBuffer","pdf","getDocument","data","promise","console","log","numPages","allLines","i","page","getPage","textContent","getTextContent","items","length","lineMap","Map","forEach","item","y","Math","round","transform","has","set","get","push","text","str","x","lines","Array","from","entries","sort","a","b","map","_","join","trim","filter","line","concat","filteredLines","match","includes","itemCodeMatch","itemCode","parts","split","itemCodePos","j","toUpperCase","dollarPos","startsWith","quantity","quantityPos","possibleQty","test","parseInt","description","slice","size","toLowerCase","color","replace","allText","itemCodes","code","error","Error"],"sources":["C:/Users/hongjie/Desktop/Warehouse Test/src/parsers/solidInkParser.js"],"sourcesContent":["import * as pdfjsLib from \"pdfjs-dist/build/pdf\";\r\nimport pdfWorker from \"pdfjs-dist/build/pdf.worker.entry\";\r\n\r\n// Ensure worker is properly configured\r\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorker;\r\n\r\n/**\r\n * parsePDFSolidInk(arrayBuffer)\r\n *  For Solid Ink style invoices\r\n */\r\nexport async function parsePDFSolidInk(arrayBuffer) {\r\n  try {\r\n    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\r\n    console.log(`PDF has ${pdf.numPages} pages`);\r\n    \r\n    let allLines = [];\r\n\r\n    for (let i = 1; i <= pdf.numPages; i++) {\r\n      const page = await pdf.getPage(i);\r\n      const textContent = await page.getTextContent();\r\n      console.log(`Page ${i} has ${textContent.items.length} text items`);\r\n      \r\n      // Group items by vertical position (approximate lines)\r\n      const lineMap = new Map();\r\n      textContent.items.forEach(item => {\r\n        const y = Math.round(item.transform[5]); // Get y coordinate\r\n        if (!lineMap.has(y)) {\r\n          lineMap.set(y, []);\r\n        }\r\n        lineMap.get(y).push({\r\n          text: item.str,\r\n          x: item.transform[4]\r\n        });\r\n      });\r\n\r\n      // Sort lines by y coordinate (top to bottom) and combine items in each line\r\n      const lines = Array.from(lineMap.entries())\r\n        .sort((a, b) => b[0] - a[0]) // Sort by y coordinate\r\n        .map(([_, items]) => {\r\n          // Sort items by x coordinate and join\r\n          return items\r\n            .sort((a, b) => a.x - b.x)\r\n            .map(item => item.text)\r\n            .join(' ')\r\n            .trim();\r\n        })\r\n        .filter(line => line.length > 0);\r\n      \r\n      allLines = allLines.concat(lines);\r\n    }\r\n\r\n    // Filter out header lines and other non-item lines\r\n    const filteredLines = allLines.filter(line => \r\n      !line.match(/^Page \\d+$/i) &&\r\n      !line.match(/^(Item|Description|Ordered|Rate|Amount)$/i) &&\r\n      !line.match(/^(Total|Subtotal|Invoice|Date|Ship To|Bill To)/i) &&\r\n      !line.match(/^Sales Order/i) &&\r\n      !line.match(/^Invoice \\d+$/i)\r\n    );\r\n\r\n    console.log('Filtered lines:', filteredLines);\r\n    \r\n    const items = [];\r\n    \r\n    // Process for item extraction\r\n    for (let i = 0; i < filteredLines.length; i++) {\r\n      const line = filteredLines[i];\r\n      \r\n      // Look for SI- item codes\r\n      if (line.includes('SI-')) {\r\n        // This is likely a product line\r\n        const itemCodeMatch = line.match(/\\b(SI-\\d+)\\b/i);\r\n        \r\n        if (itemCodeMatch) {\r\n          const itemCode = itemCodeMatch[1];\r\n          const parts = line.split(/\\s+/);\r\n          \r\n          // Find item code position in the parts array\r\n          let itemCodePos = -1;\r\n          for (let j = 0; j < parts.length; j++) {\r\n            if (parts[j].toUpperCase() === itemCode.toUpperCase()) {\r\n              itemCodePos = j;\r\n              break;\r\n            }\r\n          }\r\n          \r\n          if (itemCodePos >= 0) {\r\n            // Find first dollar sign position\r\n            let dollarPos = -1;\r\n            for (let j = 0; j < parts.length; j++) {\r\n              if (parts[j].startsWith('$')) {\r\n                dollarPos = j;\r\n                break;\r\n              }\r\n            }\r\n            \r\n            if (dollarPos > itemCodePos) {\r\n              // Extract quantity - it's usually the number right before the dollar sign\r\n              let quantity = 1;\r\n              let quantityPos = -1;\r\n              if (dollarPos > 0) {\r\n                const possibleQty = parts[dollarPos - 1];\r\n                if (/^\\d+$/.test(possibleQty)) {\r\n                  quantity = parseInt(possibleQty, 10);\r\n                  quantityPos = dollarPos - 1;\r\n                }\r\n              }\r\n              \r\n              // Extract description - it's between item code and quantity\r\n              let description = '';\r\n              if (quantityPos > itemCodePos + 1) {\r\n                // Description is between item code and quantity\r\n                description = parts.slice(itemCodePos + 1, quantityPos).join(' ');\r\n              } else if (dollarPos > itemCodePos + 1) {\r\n                // If we couldn't identify quantity, description is everything before $\r\n                description = parts.slice(itemCodePos + 1, dollarPos).join(' ');\r\n              }\r\n              \r\n              // Extract size from item code or description\r\n              let size = \"1 ounce\"; // default\r\n              if (itemCode.includes(\"-1/2\") || description.toLowerCase().includes(\"1/2 ounce\") || description.toLowerCase().includes(\"1/2oz\")) {\r\n                size = \"1/2 ounce\";\r\n              } else if (itemCode.includes(\"-4\") || description.toLowerCase().includes(\"4 ounce\") || description.toLowerCase().includes(\"4oz\")) {\r\n                size = \"4 ounce\";\r\n              } else if (itemCode.includes(\"-2\") || description.toLowerCase().includes(\"2 ounce\") || description.toLowerCase().includes(\"2oz\")) {\r\n                size = \"2 ounce\";\r\n              }\r\n              \r\n              // Clean up color name\r\n              const color = description\r\n                .replace(/-1 ounce Bottle/i, \"\")\r\n                .replace(/-1\\/2 ounce/i, \"\")\r\n                .replace(/-4 ounce/i, \"\")\r\n                .replace(/-2 ounce/i, \"\")\r\n                .replace(/\\s*Bottle.*$/i, \"\") // Remove \"Bottle\" and anything after it\r\n                .replace(/\\s*Set.*$/i, \"\") // Remove \"Set\" and anything after it\r\n                .replace(/\\s*\\([^)]*\\)/g, \"\") // Remove any parenthetical notes\r\n                .replace(/\\s+1oz\\b/i, \"\")\r\n                .replace(/\\s+2oz\\b/i, \"\")\r\n                .replace(/\\s+4oz\\b/i, \"\")\r\n                .replace(/\\s+1\\/2oz\\b/i, \"\")\r\n                .replace(/\\s+1 ounce\\b/i, \"\")\r\n                .replace(/\\s+2 ounce\\b/i, \"\")\r\n                .replace(/\\s+4 ounce\\b/i, \"\")\r\n                .replace(/\\s+1\\/2 ounce\\b/i, \"\")\r\n                .trim();\r\n\r\n              if (color && !color.match(/^(ounce|Bottle|Bottles)$/i) && quantity > 0) {\r\n                items.push({\r\n                  itemCode,\r\n                  color,\r\n                  quantity,\r\n                  size\r\n                });\r\n                console.log('Extracted item:', { itemCode, color, quantity, size });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // If we couldn't parse using line-by-line approach, try to find items directly from all text\r\n    if (items.length === 0) {\r\n      console.log('Line parsing failed, trying direct item code extraction');\r\n      \r\n      // Get all text as a single string to search for item codes\r\n      const allText = filteredLines.join(' ');\r\n      \r\n      // Extract all SI- item codes\r\n      const itemCodes = allText.match(/\\bSI-\\d+\\b/gi);\r\n      \r\n      if (itemCodes && itemCodes.length > 0) {\r\n        console.log(`Found ${itemCodes.length} item codes, creating placeholder items`);\r\n        \r\n        // Create a basic item for each code found\r\n        for (const code of itemCodes) {\r\n          items.push({\r\n            itemCode: code,\r\n            color: 'Unknown Color', // We'll need to manually edit these later\r\n            quantity: 1, // Default quantity\r\n            size: '1 ounce' // Default size\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    if (items.length === 0) {\r\n      console.error('No items could be parsed from the PDF');\r\n      throw new Error('No items could be parsed from the PDF');\r\n    }\r\n\r\n    console.log(`Successfully parsed ${items.length} items from invoice`);\r\n    return items;\r\n  } catch (error) {\r\n    console.error('Error parsing PDF:', error);\r\n    throw error;\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}