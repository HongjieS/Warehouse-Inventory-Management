{"ast":null,"code":"// src/parsers/eternalParser.js\nimport * as pdfjsLib from \"pdfjs-dist/build/pdf\";\nimport pdfWorker from \"pdfjs-dist/build/pdf.worker.entry\";\n\n// Ensure worker is properly configured\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorker;\n\n/**\r\n * parsePDFEternal(arrayBuffer)\r\n *  For Eternal Ink style invoices\r\n */\nexport async function parsePDFEternal(arrayBuffer) {\n  try {\n    const pdf = await pdfjsLib.getDocument({\n      data: arrayBuffer\n    }).promise;\n    let allText = \"\";\n    for (let i = 1; i <= pdf.numPages; i++) {\n      const page = await pdf.getPage(i);\n      const content = await page.getTextContent();\n      const pageText = content.items.map(item => item.str).join(\" \");\n      allText += pageText + \"\\n\";\n      console.log(`Page ${i} text:`, pageText); // Debug logging\n    }\n\n    // Find the start of the items section\n    const itemsStart = allText.indexOf(\"Item   Description   Ordered   Rate   Amount\");\n    if (itemsStart === -1) {\n      console.error('Could not find items section in PDF');\n      throw new Error('Could not find items section in PDF');\n    }\n\n    // Extract just the items section\n    const itemsText = allText.substring(itemsStart);\n    console.log('Items section:', itemsText); // Debug logging\n\n    // Split into lines and filter out empty lines\n    const lines = itemsText.split('\\n').filter(line => line.trim());\n    const results = [];\n    let currentItemCode = null;\n    let currentDescription = null;\n    for (const line of lines) {\n      // Skip header line\n      if (line.includes(\"Item   Description   Ordered   Rate   Amount\")) continue;\n\n      // Try to find a valid item code at the start of the line\n      const itemCodeMatch = line.match(/^([A-Z0-9]+(?:-[0-9]+(?:NB)?)?)\\s+/);\n      if (itemCodeMatch) {\n        currentItemCode = itemCodeMatch[1];\n        // Reset description when we find a new item code\n        currentDescription = null;\n      }\n\n      // If we have a valid item code, try to parse the rest of the line\n      if (currentItemCode) {\n        // Extract quantity (look for a number after the description)\n        const quantityMatch = line.match(/\\s+(\\d+)\\s+[\\d.,]+\\s+[\\d.,]+$/);\n        if (quantityMatch) {\n          const quantity = parseInt(quantityMatch[1], 10);\n\n          // Extract description (everything between item code and quantity)\n          const description = line.substring(currentItemCode.length).replace(/\\s+\\d+\\s+[\\d.,]+\\s+[\\d.,]+$/, '').trim();\n\n          // If this is a new description, update currentDescription\n          if (description && !description.match(/^(ounce|Bottle|Bottles)$/i)) {\n            currentDescription = description;\n          }\n\n          // Only process if we have a valid description\n          if (currentDescription) {\n            // Extract size from description\n            let size = \"1 ounce\"; // default\n            if (currentDescription.includes(\"1 ounce Bottle\")) {\n              size = \"1 ounce\";\n            } else if (currentDescription.includes(\"1\\/2 ounce\")) {\n              size = \"1/2 ounce\";\n            } else if (currentDescription.includes(\"4 ounce\")) {\n              size = \"4 ounce\";\n            } else if (currentDescription.includes(\"2 ounce\")) {\n              size = \"2 ounce\";\n            }\n\n            // Clean up color name\n            const color = currentDescription.replace(/-1 ounce Bottle/i, \"\").replace(/-1\\/2 ounce/i, \"\").replace(/-4 ounce/i, \"\").replace(/-2 ounce/i, \"\").replace(/\\s*\\([^)]*\\)/g, \"\") // Remove any parenthetical notes\n            .trim();\n\n            // Only add if we have a valid color name\n            if (color && !color.match(/^(ounce|Bottle|Bottles)$/i)) {\n              results.push({\n                itemCode: currentItemCode,\n                color,\n                quantity,\n                size\n              });\n            }\n          }\n        }\n      }\n    }\n    if (results.length === 0) {\n      console.error('No items could be parsed from the PDF');\n      throw new Error('No items could be parsed from the PDF');\n    }\n    console.log('Parsed results:', results); // Debug logging\n    return results;\n  } catch (error) {\n    console.error('Error parsing PDF:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["pdfjsLib","pdfWorker","GlobalWorkerOptions","workerSrc","parsePDFEternal","arrayBuffer","pdf","getDocument","data","promise","allText","i","numPages","page","getPage","content","getTextContent","pageText","items","map","item","str","join","console","log","itemsStart","indexOf","error","Error","itemsText","substring","lines","split","filter","line","trim","results","currentItemCode","currentDescription","includes","itemCodeMatch","match","quantityMatch","quantity","parseInt","description","length","replace","size","color","push","itemCode"],"sources":["C:/Users/hongjie/Desktop/Warehouse Test/src/parsers/eternalParser.js"],"sourcesContent":["// src/parsers/eternalParser.js\r\nimport * as pdfjsLib from \"pdfjs-dist/build/pdf\";\r\nimport pdfWorker from \"pdfjs-dist/build/pdf.worker.entry\";\r\n\r\n// Ensure worker is properly configured\r\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorker;\r\n\r\n/**\r\n * parsePDFEternal(arrayBuffer)\r\n *  For Eternal Ink style invoices\r\n */\r\nexport async function parsePDFEternal(arrayBuffer) {\r\n  try {\r\n    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\r\n    let allText = \"\";\r\n\r\n    for (let i = 1; i <= pdf.numPages; i++) {\r\n      const page = await pdf.getPage(i);\r\n      const content = await page.getTextContent();\r\n      const pageText = content.items.map((item) => item.str).join(\" \");\r\n      allText += pageText + \"\\n\";\r\n      console.log(`Page ${i} text:`, pageText); // Debug logging\r\n    }\r\n\r\n    // Find the start of the items section\r\n    const itemsStart = allText.indexOf(\"Item   Description   Ordered   Rate   Amount\");\r\n    if (itemsStart === -1) {\r\n      console.error('Could not find items section in PDF');\r\n      throw new Error('Could not find items section in PDF');\r\n    }\r\n\r\n    // Extract just the items section\r\n    const itemsText = allText.substring(itemsStart);\r\n    console.log('Items section:', itemsText); // Debug logging\r\n\r\n    // Split into lines and filter out empty lines\r\n    const lines = itemsText.split('\\n').filter(line => line.trim());\r\n    \r\n    const results = [];\r\n    let currentItemCode = null;\r\n    let currentDescription = null;\r\n\r\n    for (const line of lines) {\r\n      // Skip header line\r\n      if (line.includes(\"Item   Description   Ordered   Rate   Amount\")) continue;\r\n\r\n      // Try to find a valid item code at the start of the line\r\n      const itemCodeMatch = line.match(/^([A-Z0-9]+(?:-[0-9]+(?:NB)?)?)\\s+/);\r\n      if (itemCodeMatch) {\r\n        currentItemCode = itemCodeMatch[1];\r\n        // Reset description when we find a new item code\r\n        currentDescription = null;\r\n      }\r\n\r\n      // If we have a valid item code, try to parse the rest of the line\r\n      if (currentItemCode) {\r\n        // Extract quantity (look for a number after the description)\r\n        const quantityMatch = line.match(/\\s+(\\d+)\\s+[\\d.,]+\\s+[\\d.,]+$/);\r\n        if (quantityMatch) {\r\n          const quantity = parseInt(quantityMatch[1], 10);\r\n          \r\n          // Extract description (everything between item code and quantity)\r\n          const description = line\r\n            .substring(currentItemCode.length)\r\n            .replace(/\\s+\\d+\\s+[\\d.,]+\\s+[\\d.,]+$/, '')\r\n            .trim();\r\n\r\n          // If this is a new description, update currentDescription\r\n          if (description && !description.match(/^(ounce|Bottle|Bottles)$/i)) {\r\n            currentDescription = description;\r\n          }\r\n\r\n          // Only process if we have a valid description\r\n          if (currentDescription) {\r\n            // Extract size from description\r\n            let size = \"1 ounce\"; // default\r\n            if (currentDescription.includes(\"1 ounce Bottle\")) {\r\n              size = \"1 ounce\";\r\n            } else if (currentDescription.includes(\"1\\/2 ounce\")) {\r\n              size = \"1/2 ounce\";\r\n            } else if (currentDescription.includes(\"4 ounce\")) {\r\n              size = \"4 ounce\";\r\n            } else if (currentDescription.includes(\"2 ounce\")) {\r\n              size = \"2 ounce\";\r\n            }\r\n\r\n            // Clean up color name\r\n            const color = currentDescription\r\n              .replace(/-1 ounce Bottle/i, \"\")\r\n              .replace(/-1\\/2 ounce/i, \"\")\r\n              .replace(/-4 ounce/i, \"\")\r\n              .replace(/-2 ounce/i, \"\")\r\n              .replace(/\\s*\\([^)]*\\)/g, \"\") // Remove any parenthetical notes\r\n              .trim();\r\n\r\n            // Only add if we have a valid color name\r\n            if (color && !color.match(/^(ounce|Bottle|Bottles)$/i)) {\r\n              results.push({\r\n                itemCode: currentItemCode,\r\n                color,\r\n                quantity,\r\n                size\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (results.length === 0) {\r\n      console.error('No items could be parsed from the PDF');\r\n      throw new Error('No items could be parsed from the PDF');\r\n    }\r\n\r\n    console.log('Parsed results:', results); // Debug logging\r\n    return results;\r\n  } catch (error) {\r\n    console.error('Error parsing PDF:', error);\r\n    throw error;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA,OAAO,KAAKA,QAAQ,MAAM,sBAAsB;AAChD,OAAOC,SAAS,MAAM,mCAAmC;;AAEzD;AACAD,QAAQ,CAACE,mBAAmB,CAACC,SAAS,GAAGF,SAAS;;AAElD;AACA;AACA;AACA;AACA,OAAO,eAAeG,eAAeA,CAACC,WAAW,EAAE;EACjD,IAAI;IACF,MAAMC,GAAG,GAAG,MAAMN,QAAQ,CAACO,WAAW,CAAC;MAAEC,IAAI,EAAEH;IAAY,CAAC,CAAC,CAACI,OAAO;IACrE,IAAIC,OAAO,GAAG,EAAE;IAEhB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIL,GAAG,CAACM,QAAQ,EAAED,CAAC,EAAE,EAAE;MACtC,MAAME,IAAI,GAAG,MAAMP,GAAG,CAACQ,OAAO,CAACH,CAAC,CAAC;MACjC,MAAMI,OAAO,GAAG,MAAMF,IAAI,CAACG,cAAc,CAAC,CAAC;MAC3C,MAAMC,QAAQ,GAAGF,OAAO,CAACG,KAAK,CAACC,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACC,GAAG,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;MAChEZ,OAAO,IAAIO,QAAQ,GAAG,IAAI;MAC1BM,OAAO,CAACC,GAAG,CAAC,QAAQb,CAAC,QAAQ,EAAEM,QAAQ,CAAC,CAAC,CAAC;IAC5C;;IAEA;IACA,MAAMQ,UAAU,GAAGf,OAAO,CAACgB,OAAO,CAAC,8CAA8C,CAAC;IAClF,IAAID,UAAU,KAAK,CAAC,CAAC,EAAE;MACrBF,OAAO,CAACI,KAAK,CAAC,qCAAqC,CAAC;MACpD,MAAM,IAAIC,KAAK,CAAC,qCAAqC,CAAC;IACxD;;IAEA;IACA,MAAMC,SAAS,GAAGnB,OAAO,CAACoB,SAAS,CAACL,UAAU,CAAC;IAC/CF,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEK,SAAS,CAAC,CAAC,CAAC;;IAE1C;IACA,MAAME,KAAK,GAAGF,SAAS,CAACG,KAAK,CAAC,IAAI,CAAC,CAACC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;IAE/D,MAAMC,OAAO,GAAG,EAAE;IAClB,IAAIC,eAAe,GAAG,IAAI;IAC1B,IAAIC,kBAAkB,GAAG,IAAI;IAE7B,KAAK,MAAMJ,IAAI,IAAIH,KAAK,EAAE;MACxB;MACA,IAAIG,IAAI,CAACK,QAAQ,CAAC,8CAA8C,CAAC,EAAE;;MAEnE;MACA,MAAMC,aAAa,GAAGN,IAAI,CAACO,KAAK,CAAC,oCAAoC,CAAC;MACtE,IAAID,aAAa,EAAE;QACjBH,eAAe,GAAGG,aAAa,CAAC,CAAC,CAAC;QAClC;QACAF,kBAAkB,GAAG,IAAI;MAC3B;;MAEA;MACA,IAAID,eAAe,EAAE;QACnB;QACA,MAAMK,aAAa,GAAGR,IAAI,CAACO,KAAK,CAAC,+BAA+B,CAAC;QACjE,IAAIC,aAAa,EAAE;UACjB,MAAMC,QAAQ,GAAGC,QAAQ,CAACF,aAAa,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;;UAE/C;UACA,MAAMG,WAAW,GAAGX,IAAI,CACrBJ,SAAS,CAACO,eAAe,CAACS,MAAM,CAAC,CACjCC,OAAO,CAAC,6BAA6B,EAAE,EAAE,CAAC,CAC1CZ,IAAI,CAAC,CAAC;;UAET;UACA,IAAIU,WAAW,IAAI,CAACA,WAAW,CAACJ,KAAK,CAAC,2BAA2B,CAAC,EAAE;YAClEH,kBAAkB,GAAGO,WAAW;UAClC;;UAEA;UACA,IAAIP,kBAAkB,EAAE;YACtB;YACA,IAAIU,IAAI,GAAG,SAAS,CAAC,CAAC;YACtB,IAAIV,kBAAkB,CAACC,QAAQ,CAAC,gBAAgB,CAAC,EAAE;cACjDS,IAAI,GAAG,SAAS;YAClB,CAAC,MAAM,IAAIV,kBAAkB,CAACC,QAAQ,CAAC,YAAY,CAAC,EAAE;cACpDS,IAAI,GAAG,WAAW;YACpB,CAAC,MAAM,IAAIV,kBAAkB,CAACC,QAAQ,CAAC,SAAS,CAAC,EAAE;cACjDS,IAAI,GAAG,SAAS;YAClB,CAAC,MAAM,IAAIV,kBAAkB,CAACC,QAAQ,CAAC,SAAS,CAAC,EAAE;cACjDS,IAAI,GAAG,SAAS;YAClB;;YAEA;YACA,MAAMC,KAAK,GAAGX,kBAAkB,CAC7BS,OAAO,CAAC,kBAAkB,EAAE,EAAE,CAAC,CAC/BA,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAC3BA,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CACxBA,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CACxBA,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC;YAAA,CAC7BZ,IAAI,CAAC,CAAC;;YAET;YACA,IAAIc,KAAK,IAAI,CAACA,KAAK,CAACR,KAAK,CAAC,2BAA2B,CAAC,EAAE;cACtDL,OAAO,CAACc,IAAI,CAAC;gBACXC,QAAQ,EAAEd,eAAe;gBACzBY,KAAK;gBACLN,QAAQ;gBACRK;cACF,CAAC,CAAC;YACJ;UACF;QACF;MACF;IACF;IAEA,IAAIZ,OAAO,CAACU,MAAM,KAAK,CAAC,EAAE;MACxBvB,OAAO,CAACI,KAAK,CAAC,uCAAuC,CAAC;MACtD,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;IAC1D;IAEAL,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEY,OAAO,CAAC,CAAC,CAAC;IACzC,OAAOA,OAAO;EAChB,CAAC,CAAC,OAAOT,KAAK,EAAE;IACdJ,OAAO,CAACI,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAAC;IAC1C,MAAMA,KAAK;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}